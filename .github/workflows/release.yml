name: build-and-release
on:
  workflow_dispatch:  # GitHub Actions 페이지에서 수동으로 실행
  push:
    tags:
      - 'v*'  # v1.0.0 같은 태그를 push하면 실행

permissions:
  contents: write
  pull-requests: write
  packages: write

jobs:
  build-windows:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Extract VERSION from RELEASE.md
        id: get_version
        run: |
          $content = Get-Content -Path "RELEASE.md" -Raw
          if ($content -match '\[-\[VERSION:(\d+\.\d+\.\d+)\]-\]') {
            $version = $matches[1]
            echo "VERSION=$version" >> $env:GITHUB_OUTPUT
            echo "Detected VERSION: $version"
          } else {
            Write-Error "Version marker [-[VERSION:x.x.x]-] not found in RELEASE.md"
            exit 1
          }
        shell: pwsh

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller pillow

      - name: Build exe
        run: |
          pyinstaller -F -w -i favicon/favicon.ico --add-data "favicon;favicon" -n Ato pdf_email_sender_gui.py

      - name: Check secrets present
        run: |
          $missing = @()
          if ([string]::IsNullOrEmpty("${{ secrets.CODESIGN_PFX_BASE64 }}")) { $missing += 'CODESIGN_PFX_BASE64' }
          if ([string]::IsNullOrEmpty("${{ secrets.CODESIGN_PFX_PASSWORD }}")) { $missing += 'CODESIGN_PFX_PASSWORD' }
          if ($missing.Count -gt 0) {
            Write-Error ("Missing secrets: {0}" -f ($missing -join ', '))
            exit 1
          }
          Write-Host "All required secrets are present."
        shell: pwsh

      - name: Decode codesign PFX
        run: |
          # Base64로 인코딩된 PFX 인증서를 디코딩하여 파일로 저장
          $pfxBase64 = "${{ secrets.CODESIGN_PFX_BASE64 }}"
          $pfxPath = "codesign.pfx"
          
          try {
            # Base64 디코딩
            $pfxBytes = [System.Convert]::FromBase64String($pfxBase64)
            [System.IO.File]::WriteAllBytes($pfxPath, $pfxBytes)
            Write-Host "PFX certificate decoded and saved: $pfxPath"
          } catch {
            Write-Error "Failed to decode PFX certificate: $($_.Exception.Message)"
            exit 1
          }
        shell: pwsh

      - name: Sign exe with PFX
        id: sign_exe
        run: |
          $pfxPath = "codesign.pfx"
          $pfxPassword = "${{ secrets.CODESIGN_PFX_PASSWORD }}"
          
          # PFX 인증서를 PowerShell 인증서 객체로 로드
          try {
            $certPassword = ConvertTo-SecureString $pfxPassword -AsPlainText -Force
            $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($pfxPath, $certPassword)
            Write-Host "Certificate loaded: $($cert.Subject)"
            # 서명 확인 단계에서 비교할 썸프린트 저장 (GitHub Actions outputs)
            "CERT_THUMBPRINT=$($cert.Thumbprint)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          } catch {
            Write-Error "Failed to load certificate: $($_.Exception.Message)"
            exit 1
          }
          
          # PowerShell Set-AuthenticodeSignature으로 서명
          try {
            $signature = Set-AuthenticodeSignature -FilePath "dist\Ato.exe" -Certificate $cert -TimestampServer "http://timestamp.sectigo.com"
            Write-Host "Signing completed with status: $($signature.Status)"
            if ($signature.Status -eq "NotSigned" -or $signature.Status -eq "HashMismatch") {
              Write-Error "Signing failed: $($signature.Status)"
              exit 1
            }
          } catch {
            Write-Error "Signing failed: $($_.Exception.Message)"
            exit 1
          }
        shell: pwsh

      - name: Verify signature
        run: |
          $expectedThumb = "${{ steps.sign_exe.outputs.CERT_THUMBPRINT }}"
          $sig = Get-AuthenticodeSignature "dist\Ato.exe"
          Write-Host "Signature Status: $($sig.Status)"
          if ($null -ne $sig.SignerCertificate) {
            Write-Host "Signer Thumbprint: $($sig.SignerCertificate.Thumbprint)"
            Write-Host "Signer Subject   : $($sig.SignerCertificate.Subject)"
            Write-Host "Valid From       : $($sig.SignerCertificate.NotBefore)"
            Write-Host "Valid To         : $($sig.SignerCertificate.NotAfter)"
          }
          
          $now = Get-Date
          $isThumbMatch = ($null -ne $sig.SignerCertificate) -and ($sig.SignerCertificate.Thumbprint -ieq $expectedThumb)
          $hasTimestamp = ($null -ne $sig.TimeStamperCertificate)
          $isTimeValid = ($null -ne $sig.SignerCertificate) -and ($now -ge $sig.SignerCertificate.NotBefore) -and ($now -le $sig.SignerCertificate.NotAfter)
          
          # 판정 로직
          if ($sig.Status -eq "Valid") {
            Write-Host "✅ Valid signature"
            exit 0
          }
          elseif (($sig.Status -in @("UnknownError","NotTrusted")) -and $isThumbMatch -and ($hasTimestamp -or $isTimeValid)) {
            Write-Host "✅ Self-signed accepted (thumbprint match + timestamp or in-period)"
            exit 0
          }
          else {
            Write-Error ("❌ Signature verification failed. Status: {0}, Thumb match: {1}, TS: {2}, InPeriod: {3}" -f $sig.Status, $isThumbMatch, $hasTimestamp, $isTimeValid)
            exit 1
          }
        shell: pwsh


      - name: Prepare Release Notes
        run: |
          $content = Get-Content -Path "RELEASE.md" -Raw
          $version = "${{ steps.get_version.outputs.VERSION }}"
          
          # 현재 버전의 시작점 찾기
          if ($content -match "(?s)\[-\[VERSION:$version\]-\](.*?)(?=\[-\[VERSION:|$)") {
            $versionContent = $matches[1].Trim()
            $versionContent | Out-File -FilePath "release_body.md" -Encoding UTF8
            Write-Host "Extracted release notes for version $version"
          } else {
            Write-Error "Could not extract release notes for version $version"
            exit 1
          }
        shell: pwsh

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.get_version.outputs.VERSION }}
          name: Release v${{ steps.get_version.outputs.VERSION }}
          body_path: release_body.md
          files: |
            dist/Ato.exe
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
